def view_proxy(name):
    return f"""
@external
@raw_input
@raw_output
func {name}{{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    }} (selector: felt, calldata_size: felt, calldata: felt*) -> (retdata_size: felt,retdata: felt*):
    let (address) = Proxy_implementation_address.read()
    let (retdata_size: felt, retdata: felt*) = call_contract(contract_address=address, function_selector=selector, calldata_size=calldata_size, calldata=calldata)
    return (retdata_size=retdata_size, retdata=retdata)
end
"""

# TODO: will need to check the builtins from the artifact.
def mutable_proxy(func_data, auth_method):
    inputs = ", ".join([f"{arg['name']}: {arg['type']}" for arg in func_data["inputs"]])
    args = ", ".join(["address"] + [arg['name'] for arg in func_data["inputs"]])
    return f"""
@external
func {func_data["name"]}{{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    }} ({inputs}):
    alloc_locals
    {auth_method}

    let (address) = Proxy_implementation_address.read()

    ProxiedInterface.{func_data["name"]}({args})
    return ()
end
"""

def get_proxied_interface(proxied_interface, owner_args):
    def print_func(func_data):
        inputs = ", ".join([f"{arg['name']}: {arg['type']}" for arg in func_data["inputs"]])
        return f"    func {func_data['name']}({inputs}):\n    end"
    functions = "\n".join([print_func(func_data) for func_data in proxied_interface])
    return f"""
from contracts.types import (FTSpec)

@contract_interface
namespace ProxiedInterface:
    func ownerOf({owner_args}) -> (owner: felt):
    end
{functions}
end
"""

def onlyAdmin(func_data):
    return "_onlyAdmin()"

def onlyAdminAndFirst(func_data):
    return f"_onlyAdminAnd({func_data['inputs'][0]['name']})"

def get_cairo(data, spec, default_auth):
    output = ""
    proxied_interface = []

    for func_data in data["abi"]:
        if func_data["type"] != "function":
            continue
        if "stateMutability" in func_data and func_data["stateMutability"] == "view":
            output += view_proxy(func_data["name"])
            continue
        proxied_interface.append(func_data)
        output += mutable_proxy(func_data, spec[func_data['name']](func_data) if func_data['name'] in spec and spec[func_data['name']] else default_auth(func_data))

    return (output, get_proxied_interface(proxied_interface, "token_id: felt"))

def get_header():
    return """
#### Autogenerated code, see generators/backend.py

%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin, BitwiseBuiltin
from starkware.starknet.common.syscalls import get_caller_address
from starkware.starknet.common.syscalls import call_contract, delegate_l1_handler, delegate_call

from contracts.backend_proxy import (
    Proxy_implementation_address,

    _constructor,
    setImplementation,
    setAdmin,

    _onlyAdmin,
    _onlyAdminAnd,

    __default__,
)

####################
####################
####################
# Backend proxies don't delegate the calls, but instead call.
# This is because the backend proxy handles authorization,
# the actual backend contract only checks that its caller is the proxy.

@constructor
func constructor{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt):
    _constructor(owner)
    return ()
end

####################
####################
####################
# Forwarded calls
"""
