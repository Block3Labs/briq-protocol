

#### Autogenerated code, see generators/backend.py

%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin, BitwiseBuiltin
from starkware.starknet.common.syscalls import get_caller_address
from starkware.starknet.common.syscalls import call_contract, delegate_l1_handler, delegate_call

from contracts.backend_proxy import (
    Proxy_implementation_address,

    _constructor,
    setImplementation,
    setAdmin,

    _only,
    _onlyAdmin,
    _onlyAdminAnd,

    __default__,
)

####################
####################
####################
# Backend proxies don't delegate the calls, but instead call.
# This is because the backend proxy handles authorization,
# the actual backend contract only checks that its caller is the proxy.

@constructor
func constructor{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt):
    _constructor(owner)
    return ()
end

####################
####################
####################
# Forwarded calls


@storage_var
func _mint_contract() -> (address: felt):
end

@external
func setMintContract{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (address: felt):
    _onlyAdmin()
    _mint_contract.write(address)
    return ()
end


@view
func getMintContract{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } () -> (address: felt):
    let (addr) = _mint_contract.read()
    return (addr)
end

func _onlyAdminAndMintContract{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } ():
    let (address) = _mint_contract.read()
    _onlyAdminAnd(address)
    return ()
end


from contracts.types import (FTSpec, NFTSpec)

@contract_interface
namespace ProxiedInterface:
    func setProxyAddress(address: felt) -> ():
    end
    func setSetBackendAddress(address: felt) -> ():
    end
    func balanceOf(owner: felt, material: felt) -> (balance: felt):
    end
    func multiBalanceOf(owner: felt, materials_len: felt, materials: felt*) -> (balances_len: felt, balances: felt*):
    end
    func balanceDetailsOf(owner: felt, material: felt) -> (ft_balance: felt, nft_ids_len: felt, nft_ids: felt*):
    end
    func tokenOfOwnerByIndex(owner: felt, material: felt, index: felt) -> (token_id: felt):
    end
    func ownerOf(token_id: felt) -> (owner: felt):
    end
    func totalSupply(material: felt) -> (supply: felt):
    end
    func mintFT(owner: felt, material: felt, qty: felt) -> ():
    end
    func mintOneNFT(owner: felt, material: felt, uid: felt) -> ():
    end
    func transferFT(sender: felt, recipient: felt, material: felt, qty: felt) -> ():
    end
    func transferOneNFT(sender: felt, recipient: felt, material: felt, briq_token_id: felt) -> ():
    end
    func transferNFT(sender: felt, recipient: felt, material: felt, token_ids_len: felt, token_ids: felt*) -> ():
    end
    func mutateFT(owner: felt, source_material: felt, target_material: felt, qty: felt) -> ():
    end
    func mutateOneNFT(owner: felt, source_material: felt, target_material: felt, uid: felt, new_uid: felt) -> ():
    end
    func convertOneToFT(owner: felt, material: felt, token_id: felt) -> ():
    end
    func convertToFT(owner: felt, token_ids_len: felt, token_ids: NFTSpec*) -> ():
    end
    func convertOneToNFT(owner: felt, material: felt, uid: felt) -> ():
    end
end


@external
func setProxyAddress{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (address: felt):
    alloc_locals
    _onlyAdmin()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.setProxyAddress(__address, address)
    return ()
end

@external
func setSetBackendAddress{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (address: felt):
    alloc_locals
    _onlyAdmin()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.setSetBackendAddress(__address, address)
    return ()
end

@view
func balanceOf{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (owner: felt, material: felt) -> (balance: felt):
    let (__address) = Proxy_implementation_address.read()
    let (balance: felt) = ProxiedInterface.balanceOf(__address, owner, material)
    return (balance)
end

@view
func multiBalanceOf{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (owner: felt, materials_len: felt, materials: felt*) -> (balances_len: felt, balances: felt*):
    alloc_locals
    let (__address) = Proxy_implementation_address.read()
    local pedersen_ptr: HashBuiltin* = pedersen_ptr
    let (balances_len: felt, balances: felt*) = ProxiedInterface.multiBalanceOf(__address, owner, materials_len, materials)
    return (balances_len, balances)
end

@view
func balanceDetailsOf{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (owner: felt, material: felt) -> (ft_balance: felt, nft_ids_len: felt, nft_ids: felt*):
    let (__address) = Proxy_implementation_address.read()
    let (ft_balance: felt, nft_ids_len: felt, nft_ids: felt*) = ProxiedInterface.balanceDetailsOf(__address, owner, material)
    return (ft_balance, nft_ids_len, nft_ids)
end

@view
func tokenOfOwnerByIndex{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (owner: felt, material: felt, index: felt) -> (token_id: felt):
    let (__address) = Proxy_implementation_address.read()
    let (token_id: felt) = ProxiedInterface.tokenOfOwnerByIndex(__address, owner, material, index)
    return (token_id)
end

@view
func ownerOf{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (token_id: felt) -> (owner: felt):
    let (__address) = Proxy_implementation_address.read()
    let (owner: felt) = ProxiedInterface.ownerOf(__address, token_id)
    return (owner)
end

@view
func totalSupply{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (material: felt) -> (supply: felt):
    let (__address) = Proxy_implementation_address.read()
    let (supply: felt) = ProxiedInterface.totalSupply(__address, material)
    return (supply)
end

@external
func mintFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, material: felt, qty: felt):
    alloc_locals
    _onlyAdminAndMintContract()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.mintFT(__address, owner, material, qty)
    return ()
end

@external
func mintOneNFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, material: felt, uid: felt):
    alloc_locals
    _onlyAdminAndMintContract()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.mintOneNFT(__address, owner, material, uid)
    return ()
end

@external
func transferFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (sender: felt, recipient: felt, material: felt, qty: felt):
    alloc_locals
    _only(sender)
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.transferFT(__address, sender, recipient, material, qty)
    return ()
end

@external
func transferOneNFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (sender: felt, recipient: felt, material: felt, briq_token_id: felt):
    alloc_locals
    _only(sender)
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.transferOneNFT(__address, sender, recipient, material, briq_token_id)
    return ()
end

@external
func transferNFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (sender: felt, recipient: felt, material: felt, token_ids_len: felt, token_ids: felt*):
    alloc_locals
    _only(sender)
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.transferNFT(__address, sender, recipient, material, token_ids_len, token_ids)
    return ()
end

@external
func mutateFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, source_material: felt, target_material: felt, qty: felt):
    alloc_locals
    _onlyAdmin()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.mutateFT(__address, owner, source_material, target_material, qty)
    return ()
end

@external
func mutateOneNFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, source_material: felt, target_material: felt, uid: felt, new_uid: felt):
    alloc_locals
    _onlyAdmin()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.mutateOneNFT(__address, owner, source_material, target_material, uid, new_uid)
    return ()
end

@external
func convertOneToFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, material: felt, token_id: felt):
    alloc_locals
    _onlyAdmin()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.convertOneToFT(__address, owner, material, token_id)
    return ()
end

@external
func convertToFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, token_ids_len: felt, token_ids: NFTSpec*):
    alloc_locals
    _onlyAdmin()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.convertToFT(__address, owner, token_ids_len, token_ids)
    return ()
end

@external
func convertOneToNFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, material: felt, uid: felt):
    alloc_locals
    _onlyAdmin()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.convertOneToNFT(__address, owner, material, uid)
    return ()
end

    
