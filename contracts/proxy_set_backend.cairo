
#### Autogenerated code, see generators/backend.py

%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin, BitwiseBuiltin
from starkware.starknet.common.syscalls import get_caller_address
from starkware.starknet.common.syscalls import call_contract, delegate_l1_handler, delegate_call

from contracts.backend_proxy import (
    Proxy_implementation_address,

    _constructor,
    setImplementation,

    _onlyAdmin,
    _onlyAdminAnd,

    __default__,
)

####################
####################
####################
# Backend proxies don't delegate the calls, but instead call.
# This is because the backend proxy handles authorization,
# the actual backend contract only checks that its caller is the proxy.

@constructor
func constructor{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt):
    _constructor(owner)
    return ()
end

####################
####################
####################
# Forwarded calls


from contracts.types import (FTSpec)

@contract_interface
namespace ProxiedInterface:
    func ownerOf(token_id: felt):
    end
    func setProxyAddress(address: felt):
    end
    func setBriqBackendAddress(address: felt):
    end
    func assemble(owner: felt, token_id_hint: felt, fts_len: felt, fts: FTSpec*, nfts_len: felt, nfts: felt*):
    end
    func disassemble(owner: felt, token_id: felt, fts_len: felt, fts: FTSpec*, nfts_len: felt, nfts: felt*):
    end
    func setTokenUri(token_id: felt, uri_len: felt, uri: felt*):
    end
    func transferOneNFT(sender: felt, recipient: felt, token_id: felt):
    end
end

@external
func setProxyAddress{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (address: felt):
    alloc_locals
    _onlyAdminAnd(address)

    let (address) = Proxy_implementation_address.read()

    ProxiedInterface.setProxyAddress(address, address)
    return ()
end

@external
func setBriqBackendAddress{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (address: felt):
    alloc_locals
    _onlyAdminAnd(address)

    let (address) = Proxy_implementation_address.read()

    ProxiedInterface.setBriqBackendAddress(address, address)
    return ()
end

@external
@raw_input
@raw_output
func balanceOf{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (selector: felt, calldata_size: felt, calldata: felt*) -> (retdata_size: felt,retdata: felt*):
    let (address) = Proxy_implementation_address.read()
    let (retdata_size: felt, retdata: felt*) = call_contract(contract_address=address, function_selector=selector, calldata_size=calldata_size, calldata=calldata)
    return (retdata_size=retdata_size, retdata=retdata)
end

@external
@raw_input
@raw_output
func balanceDetailsOf{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (selector: felt, calldata_size: felt, calldata: felt*) -> (retdata_size: felt,retdata: felt*):
    let (address) = Proxy_implementation_address.read()
    let (retdata_size: felt, retdata: felt*) = call_contract(contract_address=address, function_selector=selector, calldata_size=calldata_size, calldata=calldata)
    return (retdata_size=retdata_size, retdata=retdata)
end

@external
@raw_input
@raw_output
func tokenOfOwnerByIndex{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (selector: felt, calldata_size: felt, calldata: felt*) -> (retdata_size: felt,retdata: felt*):
    let (address) = Proxy_implementation_address.read()
    let (retdata_size: felt, retdata: felt*) = call_contract(contract_address=address, function_selector=selector, calldata_size=calldata_size, calldata=calldata)
    return (retdata_size=retdata_size, retdata=retdata)
end

@external
@raw_input
@raw_output
func ownerOf{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (selector: felt, calldata_size: felt, calldata: felt*) -> (retdata_size: felt,retdata: felt*):
    let (address) = Proxy_implementation_address.read()
    let (retdata_size: felt, retdata: felt*) = call_contract(contract_address=address, function_selector=selector, calldata_size=calldata_size, calldata=calldata)
    return (retdata_size=retdata_size, retdata=retdata)
end

@external
@raw_input
@raw_output
func tokenUri{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (selector: felt, calldata_size: felt, calldata: felt*) -> (retdata_size: felt,retdata: felt*):
    let (address) = Proxy_implementation_address.read()
    let (retdata_size: felt, retdata: felt*) = call_contract(contract_address=address, function_selector=selector, calldata_size=calldata_size, calldata=calldata)
    return (retdata_size=retdata_size, retdata=retdata)
end

@external
func assemble{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, token_id_hint: felt, fts_len: felt, fts: FTSpec*, nfts_len: felt, nfts: felt*):
    alloc_locals
    _onlyAdminAnd(owner)

    let (address) = Proxy_implementation_address.read()

    ProxiedInterface.assemble(address, owner, token_id_hint, fts_len, fts, nfts_len, nfts)
    return ()
end

@external
func disassemble{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, token_id: felt, fts_len: felt, fts: FTSpec*, nfts_len: felt, nfts: felt*):
    alloc_locals
    _onlyAdminAnd(owner)

    let (address) = Proxy_implementation_address.read()

    ProxiedInterface.disassemble(address, owner, token_id, fts_len, fts, nfts_len, nfts)
    return ()
end

@external
func setTokenUri{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (token_id: felt, uri_len: felt, uri: felt*):
    alloc_locals
    _onlyAdminAnd(token_id)

    let (address) = Proxy_implementation_address.read()

    ProxiedInterface.setTokenUri(address, token_id, uri_len, uri)
    return ()
end

@external
func transferOneNFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (sender: felt, recipient: felt, token_id: felt):
    alloc_locals
    _onlyAdminAnd(sender)

    let (address) = Proxy_implementation_address.read()

    ProxiedInterface.transferOneNFT(address, sender, recipient, token_id)
    return ()
end


