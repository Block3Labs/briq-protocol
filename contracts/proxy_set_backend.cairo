

#### Autogenerated code, see generators/backend.py

%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin, BitwiseBuiltin
from starkware.starknet.common.syscalls import get_caller_address
from starkware.starknet.common.syscalls import call_contract, delegate_l1_handler, delegate_call

from contracts.backend_proxy import (
    Proxy_implementation_address,

    _constructor,
    setImplementation,
    setAdmin,

    _only,
    _onlyAdmin,
    _onlyAdminAnd,

    __default__,
)

####################
####################
####################
# Backend proxies don't delegate the calls, but instead call.
# This is because the backend proxy handles authorization,
# the actual backend contract only checks that its caller is the proxy.

@constructor
func constructor{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt):
    _constructor(owner)
    return ()
end

####################
####################
####################
# Forwarded calls


from contracts.types import (FTSpec, NFTSpec)

@contract_interface
namespace ProxiedInterface:
    func setProxyAddress(address: felt) -> ():
    end
    func setBriqBackendAddress(address: felt) -> ():
    end
    func balanceOf(owner: felt) -> (balance: felt):
    end
    func balanceDetailsOf(owner: felt) -> (token_ids_len: felt, token_ids: felt*):
    end
    func tokenOfOwnerByIndex(owner: felt, index: felt) -> (token_id: felt):
    end
    func ownerOf(token_id: felt) -> (owner: felt):
    end
    func tokenUri(token_id: felt) -> (uri_len: felt, uri: felt*):
    end
    func assemble(owner: felt, token_id_hint: felt, fts_len: felt, fts: FTSpec*, nfts_len: felt, nfts: felt*, uri_len: felt, uri: felt*) -> ():
    end
    func setTokenUri(token_id: felt, uri_len: felt, uri: felt*) -> ():
    end
    func updateBriqs(owner: felt, token_id: felt, add_fts_len: felt, add_fts: FTSpec*, add_nfts_len: felt, add_nfts: felt*, remove_fts_len: felt, remove_fts: FTSpec*, remove_nfts_len: felt, remove_nfts: felt*, uri_len: felt, uri: felt*) -> ():
    end
    func disassemble(owner: felt, token_id: felt, fts_len: felt, fts: FTSpec*, nfts_len: felt, nfts: felt*) -> ():
    end
    func transferOneNFT(sender: felt, recipient: felt, token_id: felt) -> ():
    end
end


from contracts.allowance import (
    getApproved,
    isApprovedForAll,
    _setApprovalForAll_noauth,
    _approve_noauth,
)

# Not OZ interface
@external
func approve{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (approved_address: felt, token_id: felt):
    let (proxy) = Proxy_implementation_address.read()
    let (owner) = ProxiedInterface.ownerOf(proxy, token_id)
    _onlyAdminAnd(owner)
    _approve_noauth(approved_address, token_id)
    return ()
end

@external
func setApprovalForAll{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (approved_address: felt, allowed: felt):
    let (owner) = get_caller_address()
    _setApprovalForAll_noauth(on_behalf_of=owner, approved_address=approved_address, allowed=allowed)
    return ()
end

########################
########################

func _onlyApproved{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (sender: felt, token_id: felt):
    let (caller) = get_caller_address()
    if sender == caller:
        return ()
    end
    let (isOperator) = isApprovedForAll(sender, caller)
    if isOperator - 1 == 0:
        return ()
    end
    let (approved) = getApproved(token_id)
    _only(approved)
    return ()
end


@external
func setProxyAddress{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (address: felt):
    alloc_locals
    _onlyAdmin()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.setProxyAddress(__address, address)
    return ()
end

@external
func setBriqBackendAddress{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (address: felt):
    alloc_locals
    _onlyAdmin()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.setBriqBackendAddress(__address, address)
    return ()
end

@view
func balanceOf{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (owner: felt) -> (balance: felt):
    let (__address) = Proxy_implementation_address.read()
    let (balance: felt) = ProxiedInterface.balanceOf(__address, owner)
    return (balance)
end

@view
func balanceDetailsOf{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (owner: felt) -> (token_ids_len: felt, token_ids: felt*):
    let (__address) = Proxy_implementation_address.read()
    let (token_ids_len: felt, token_ids: felt*) = ProxiedInterface.balanceDetailsOf(__address, owner)
    return (token_ids_len, token_ids)
end

@view
func tokenOfOwnerByIndex{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (owner: felt, index: felt) -> (token_id: felt):
    let (__address) = Proxy_implementation_address.read()
    let (token_id: felt) = ProxiedInterface.tokenOfOwnerByIndex(__address, owner, index)
    return (token_id)
end

@view
func ownerOf{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (token_id: felt) -> (owner: felt):
    let (__address) = Proxy_implementation_address.read()
    let (owner: felt) = ProxiedInterface.ownerOf(__address, token_id)
    return (owner)
end

@view
func tokenUri{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr
    } (token_id: felt) -> (uri_len: felt, uri: felt*):
    let (__address) = Proxy_implementation_address.read()
    let (uri_len: felt, uri: felt*) = ProxiedInterface.tokenUri(__address, token_id)
    return (uri_len, uri)
end

@external
func assemble{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, token_id_hint: felt, fts_len: felt, fts: FTSpec*, nfts_len: felt, nfts: felt*, uri_len: felt, uri: felt*):
    alloc_locals
    _only(owner)
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.assemble(__address, owner, token_id_hint, fts_len, fts, nfts_len, nfts, uri_len, uri)
    return ()
end

@external
func setTokenUri{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (token_id: felt, uri_len: felt, uri: felt*):
    alloc_locals
    _onlyAdmin()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.setTokenUri(__address, token_id, uri_len, uri)
    return ()
end

@external
func updateBriqs{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, token_id: felt, add_fts_len: felt, add_fts: FTSpec*, add_nfts_len: felt, add_nfts: felt*, remove_fts_len: felt, remove_fts: FTSpec*, remove_nfts_len: felt, remove_nfts: felt*, uri_len: felt, uri: felt*):
    alloc_locals
    _onlyAdmin()
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.updateBriqs(__address, owner, token_id, add_fts_len, add_fts, add_nfts_len, add_nfts, remove_fts_len, remove_fts, remove_nfts_len, remove_nfts, uri_len, uri)
    return ()
end

@external
func disassemble{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (owner: felt, token_id: felt, fts_len: felt, fts: FTSpec*, nfts_len: felt, nfts: felt*):
    alloc_locals
    _only(owner)
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.disassemble(__address, owner, token_id, fts_len, fts, nfts_len, nfts)
    return ()
end

@external
func transferOneNFT{
        syscall_ptr: felt*,
        pedersen_ptr: HashBuiltin*,
        range_check_ptr
    } (sender: felt, recipient: felt, token_id: felt):
    alloc_locals
    
    _onlyApproved(sender, token_id)
    # Reset approval (0 cost if was 0 before)
    _approve_noauth(0, token_id)
    let (__address) = Proxy_implementation_address.read()
    ProxiedInterface.transferOneNFT(__address, sender, recipient, token_id)
    return ()
end

    
